[{"content":"Xin chào mọi người. Hôm nay chúng ta sẽ cùng tìm hiểu cách để có thể triển khai 1 ứng dụng NodeJS trên EC2 và thông tin dữ liệu được\nlưu ở S3 trên AWS nhé!\nMô hình triển khai Mình sẽ nói qua chút về mô hình triển khai của bài Lab này, yêu cầu của bài lab bao gồm:\n Chuẩn bị EC2 đã được cấu hình IAM Rule truy cập S3 Cài đặt NodeJS lên EC2 Lấy code NodeJS truy cập S3 và hiển thị nội dung(danh sách file, ảnh) trong S3 lên web  Chúng ta sẽ đến bài lab ngay bây giờ 😄\n1. Chuẩn bị EC2 đã được cấu hình IAM Rule truy cập S3 Trước hết mình đã tạo 1 VPC, với subnet public và subnet private ở bài trước, bạn có thể đọc lại bài VPC trong AWS của mình\nBước 1: Tạo EC2, S3 Bucket với giao diện AWS Console Chúng ta lần lượt tạo EC2 và S3 Bucket như sau:\nchú ý ở bước tạo Network setting chúng ta sẽ chọn VPC public mà chúng ta tạo ở bài trước\nCác bước khác bạn làm tương tự như bài hướng dẫn về EC2\nTiếp theo mình sẽ tạo 1 S3 Bucket, nếu bạn chưa biết S3 Bucket là gì thì S3 Bucket là dịch vụ đám mây lưu trữ do đó bạn có thể tải lên các tệp, các tài liệu,\ncác dữ liệu tải về của người dùng hoặc các bản sao lưu.\nĐể hiểu về Amazon S3, bạn cần nắm 1 số khái niệm cơ bản:\n Amazon S3 lưu trữ dữ liệu như các object trong các bucket. Một object gồm 1 file và metadata mô tả cho file (tùy chọn). Để lưu 1 object trong Amazon S3, bạn tải file lên 1 bucket. Khi đã tải file, bạn có thể gán quyền cho đối tượng cũng như bổ sung metadata. Bucket là các thùng chứa cho các object. Bạn có thể tạo 1 hay nhiều bucket.\nVới mỗi bucket, bạn có thể điều khiển việc truy xuất đến nó (ai có thể tạo, xóa và xem các object trong bucket), xem nhật ký truy xuất đến bucket và đến các object bên trong, cũng như chọn region mà Amazon S3 sẽ lưu bucket và nội dung trong nó. Chú ý là mỗi một tài khoản chỉ tạo được tối đa là 100 buckets, và Bucket có tên là duy nhất  Mình sẽ tạo 1 S3 Bucket như sau:\nBạn cần bỏ tích chọn mục này\nBước 2: Tạo IAM Role Tạo 1 rule cho phép EC2 truy cập S3 như sau\nBước 3: Chỉnh sửa Bucket Policy Bước 4: Kiểm tra EC2 truy cập S3 mà không cần lưu trữ use/key/pass 2. Cài đặt NodeJS lên EC2 Bạn có thể deploy ứng dựng Nodejs từ sourecode sau\n3. Lấy code NodeJS truy cập S3 và hiển thị nội dung(danh sách file, ảnh) trong S3 lên web ","description":"","id":4,"section":"posts","tags":["AWS"],"title":"[Dành cho Beginner] Hướng dẫn triển khai ứng dụng NodeJS cho AWS trên EC2 và S3","uri":"https://hungpt.info/en/posts/deploy_nodejd_ec2_s3_in_aws/"},{"content":"Xin chào mọi người. Hôm nay chúng ta sẽ cùng tìm hiểu về VPN trong AWS.\n","description":"","id":5,"section":"posts","tags":["AWS"],"title":"[Dành cho Beginner] VPN trong AWS","uri":"https://hungpt.info/en/posts/vpn_in_aws/"},{"content":"Xin chào mọi người. Hôm nay chúng ta sẽ cùng tìm hiểu về VPC (Virtual Private Cloud) trong AWS.\nTổng quan về VPC Virtual Private Cloud là gì ? Amazon Virtual Private Cloud (Amazon VPC) là dịch vụ cho phép bạn khởi chạy các tài nguyên AWS trong mạng ảo cô lập theo\nlogic mà bạn xác định.\nBạn có toàn quyền kiểm soát môi trường mạng ảo của mình, bao gồm lựa chọn dải địa chỉ IP, tạo các mạng con,\ncấu hình các bảng định tuyến và cổng kết nối mạng. Bạn có thể dùng cả IPv4 và IPv6 cho hầu hết các tài nguyên trong đám\nmây riêng ảo, giúp bảo mật nghiêm ngặt và truy cập dễ dàng các tài nguyên cũng như ứng dụng.\nLà một trong các dịch vụ nền tảng của AWS, Amazon VPC sẽ giúp bạn dễ dàng tùy chỉnh cấu hình mạng của VPC. Bạn có thể\ntạo một mạng con công khai cho các máy chủ web có quyền truy cập internet. Dịch vụ này cũng cho phép bạn đặt các hệ\nthống backend, như máy chủ ứng dụng hoặc cơ sở dữ liệu, trong mạng con riêng tư không có quyền truy cập internet. Với\nAmazon VPC, bạn có thể sử dụng nhiều lớp bảo mật, bao gồm các nhóm bảo mật và danh sách kiểm soát truy cập mạng, để giúp\nkiểm soát quyền truy cập vào các phiên bản Amazon EC2 trong mỗi mạng con.\n","description":"","id":6,"section":"posts","tags":["AWS"],"title":"[Dành cho Beginner] VPC trong AWS","uri":"https://hungpt.info/en/posts/vpc_in_aws/"},{"content":"Xin chào mọi người. Hôm nay chúng ta sẽ cùng tìm hiểu về IAM (Identity and Access Management) trong AWS.\nChắc hẳn khi mới bắt đầu tìm hiểu về Amazon Web Services, IAM là một trong những khái niệm mà chúng ta tiếp xúc đầu tiên. Cùng bắt đầu thôi!\n1.IAM (Identity and Access Management) là gì? IAM (Identity and Access Management) tạm dịch là \u0026ldquo;Quản lý truy cập và nhận dạng\u0026rdquo; là một dịch vụ web giúp bạn kiểm soát\ntruy cập an toàn vào các tài nguyên AWS. Bạn sử dụng IAM để kiểm soát ai được xác thực (đăng nhập) và được ủy quyền (có quyền) để sử dụng tài nguyên.\nIAM cung cấp cho bạn một số tính năng sau:\n Chia sẻ quyền truy cập vào tài khoản AWS của bạn: Bạn có thể cấp cho người khác quyền quản trị và sử dụng tài nguyên trong tài khoản AWS của bạn mà không phải chia sẻ mật khẩu hoặc khóa truy cập. Cấp phép chi tiết: Bạn có thể cấp các quyền khác nhau cho những người khác nhau sử dụng các tài nguyên khác nhau. Truy cập an toàn vào tài nguyên AWS cho các ứng dụng chạy trên Amazon EC2 Bạn có thể cung cấp thông tin đăng nhập an toàn cho các ứng dụng chạy trên các phiên bản EC2 Xác thực đa yếu tố (MFA): Bạn có thể thêm xác thực hai yếu tố vào tài khoản của mình và cho từng người dùng để bảo mật hơn. Thông tin nhận dạng để đảm bảo: Nếu bạn sử dụng AWS CloudTrail, bạn sẽ nhận được các bản ghi nhật ký bao gồm thông tin về những người đã yêu cầu tài nguyên trong tài khoản của bạn. Thông tin đó dựa trên danh tính IAM. Sử dụng miễn phí: IAM được cung cấp miễn phí. Bạn chỉ phải trả phí cho việc sử dụng các dịch vụ của AWS trên tài khoản của bạn.  2. User, Group, Role, Policy IAM là khái niệm vô cùng quan trọng trong bảo mật của AWS. Hiểu về cách IAM hoạt động chính là hiểu về việc xác thực, cấp phép và uỷ quyền trong AWS.\nKhi đăng kí và truy cập tài khoản, đầu tiên, bạn sẽ đăng nhập với tư cách là người dùng gốc (Tài khoản root)\nTuy nhiên, khi bạn sử dụng thông tin đăng nhập tài khoản root, bạn có quyền truy cập đầy đủ, không hạn chế vào tất cả các tài nguyên trong tài khoản AWS của bạn, bao gồm quyền truy cập vào thông tin thanh toán và khả năng thay đổi mật khẩu của bạn. Mức truy cập này là cần thiết khi bạn lần đầu tiên thiết lập tài khoản của mình. Tuy nhiên, vì lý do bảo mật cho cả bản thân và những người khác cần làm việc với tài nguyên AWS của bạn, AWS khuyên bạn không nên sử dụng thông tin xác thực người dùng root để truy cập và sử dụng AWS, thay vào đó là việc sử dụng tài khoản IAM User. Đó cũng là lý do vì sao chúng ta cần hiểu rõ các khái niệm tiếp sau đây về User, Group, Role, Policy.\nChúng ta hãy nhìn vào sơ đồ dưới đây để hiểu từng khái niệm.\nUser Là tài khoản với sự uỷ nhiệm (Credentials) vĩnh viễn, được tạo và cấp quyền bời tài khoản root. Chúng ta đăng nhập vào User bằng. 1 User bao gồm user name, console password, accesskey,\u0026hellip;\nGroup Là 1 nhóm bao gồm nhiều user. Đồng thời, 1 user cũng có thể thuộc về nhiều group.\nRole Là 1 tập các quyền mà bạn có thể sử dụng để truy cập các tài nguyên AWS mà bạn cần. Tuy nhiên, bạn không đăng nhập vào role, role không có password or access keys mà bạn có thể switch sang role sau khi đăng nhập bằng user của bạn. Có thể hiểu role là một tài khoản với sự uỷ nhiệm (Credentials) tạm thời để giải quyết những cồng việc khác nhau với vai trò khác nhau.\nPolicy Là 1 đối tượng khi liên kết với user, group hay role thì sẽ định nghĩa quyền của chúng.\nMọi thứ trong AWS đều là API, điều này rất quan trọng, nó cũng có nghĩa là để thực thi API, trước hết chúng ta phải xác thực, nhưng sau đó chúng ta phải ủy quyền. Đó chính là lý do vì sao chúng ta cần có Policy.\nPolicy là những file JSON được đính kèm trực tiếp vào User, Group hoặc Role. 1 Policy sẽ có dạng cấu trúc cơ bản như sau:\n { \u0026quot;Version\u0026quot;: \u0026quot;2012-10-17\u0026quot;, \u0026quot;Statement\u0026quot;: [ { \u0026quot;Sid\u0026quot;: \u0026quot;Stmt1571671788500\u0026quot;, \u0026quot;Action\u0026quot;: [ \u0026quot;ec2:CreateImage\u0026quot;, \u0026quot;ec2:CreateNetworkAcl\u0026quot;, \u0026quot;ec2:CreateNetworkAclEntry\u0026quot;, \u0026quot;ec2:CreateVpc\u0026quot; ], \u0026quot;Effect\u0026quot;: \u0026quot;Allow\u0026quot;, \u0026quot;Resource\u0026quot;: \u0026quot;*\u0026quot; }, { \u0026quot;Sid\u0026quot;: \u0026quot;Stmt1571717009297\u0026quot;, \u0026quot;Action\u0026quot;: [ \u0026quot;s3:CreateBucket\u0026quot;, \u0026quot;s3:CreateJob\u0026quot;, \u0026quot;s3:DeleteBucket\u0026quot;, \u0026quot;s3:DeleteBucketPolicy\u0026quot;, \u0026quot;s3:DeleteBucketWebsite\u0026quot;, \u0026quot;s3:DeleteObject\u0026quot; ], \u0026quot;Effect\u0026quot;: \u0026quot;Allow\u0026quot;, \u0026quot;Resource\u0026quot;: \u0026quot;*\u0026quot; } ] } Version : Phiên bản của ngôn ngữ policy\nStatement: Là thành phần chính cho một Policy. Phần tử này là bắt buộc. Statement có thể chứa một câu lệnh hoặc một mảng các câu lệnh riêng lẻ. Mỗi khối câu lệnh riêng lẻ phải được đặt trong dấu ngoặc nhọn {}. Nhiều câu lệnh, mảng phải được đặt trong dấu ngoặc vuông [].\n Sid: (statement ID) là một ID tuỳ chọn bạn cung cấp cho mỗi câu lệnh trong statement, Effect: Là 1 thành phần bắt buộc và chỉ định kết quả statement được chấp nhận hoặc từ chối (Alllow/Deny) Action: Mô tả hành động hoặc hành động cụ thể sẽ được phép hoặc bị từ chối. Resource: Chỉ định những tài nguyên AWS được áp dụng trong các Action. Condition: Chỉ định các điều kiện bắt buộc để policy có hiệu lực  Với Policy, chúng ta có thể quy định rõ User, Group hay Role có quyền hạn sử dụng những tài nguyên nào.\nBạn có thể dễ dàng quản lý User, Group cũng như Role trong tài khoản AWS của mình tại mục Identity and Access Management (IAM) trên giao diện AWS Management Console.\nTóm tắt Vậy những điều chúng ta cần hiểu một cách ngắn gọn về IAM đó là:\n IAM giúp chúng ta xác thực và uỷ quyền khi sử dụng tài nguyên AWS. Tài khoản root tạo ra các tài khoản user. Các user này thuộc về các group nhất định. Chúng ta đăng nhập vào user, switch sang role với 1 vai trò nhất định đi kèm với các quyền sử dụng tài nguyên được quy định dựa vào policy.\nHy vọng có thể giúp mọi người hiểu về IAM.  Cảm ơn các bạn đã theo dõi blog! Hẹn gặp lại vào những blog tiếp theo!\n","description":"","id":7,"section":"posts","tags":["AWS"],"title":"[Dành cho Beginner] IAM trong AWS","uri":"https://hungpt.info/en/posts/aws_lab_1/"},{"content":"Mình sẽ quay trở lại sớm với loại bài về K8s nhé 😄\u0026hellip;\n","description":"[K8S] - Phần 1: K8S là gì ?","id":8,"section":"posts","tags":["DevOps","Kubernetes","Linux","Docker","AWS"],"title":"[K8S] - Phần 1: K8S là gì ?","uri":"https://hungpt.info/en/posts/k8s_la_gi_part1/"},{"content":"Nếu bạn đọc soure code của core Odoo, đôi khi bạn sẽ tìm thấy safe_eval. Bạn đã bao giờ tự hỏi, safe_eval là gì chưa? Và nó sử dụng để làm gì?\nNếu bạn đọc mã nguồn của Odoo, bạn sẽ thấy rằng, safe_eval thực ra chỉ là một hàm/module được viết bằng python.\nNếu bạn không biết, module eval được sử dụng để xử lý các biểu thức với kiểu dữ liệu là chuỗi, để chúng có thể được đọc dưới dạng\nphép toán hoặc thậm chí là 1 đoạn mã python hợp lệ. Giả sử chúng ta có 1 biến với kiểu dữ liệu là chuỗi như bên dưới đây:\nmy_string = '100 + 5' Bằng cách sử dụng eval chúng ta có thể biến chuỗi trên thành 1 phép toán hợp lệ như sau:\nmy_string = '100 + 5' value = eval(my_string) print(value) Như bạn thấy kết quả của phép toán là 105 là kết quả của phép tính 100 + 5.\nModule eval cũng có thể được sử dụng ở những trường hợp biểu thức được gán vào các biến như sau:\na = 100 b = 5 my_string = 'a + b' value = eval(my_string) Hoặc chúng ta cũng có thể biết như sau:\nmy_string = 'a + b' value = eval(my_string, {'a': 100, 'b': 5}) Như mình đã viết trước đó, module safe_eval thực sự chỉ là thư viện tích hợp eval của python và sửa đổi một chút.\nDo đó, đoan mã trên cũng có thể được viết bằng module safe_eval như sau:\nfrom odoo.tools.safe_eval import safe_eval my_string = 'a + b' value = safe_eval(my_string, {'a': 100, 'b': 5}) Vậy sự khác biệt khi chúng ta sử dụng eval và safe_eval ở đây là gì?\nsafe_eval sẽ đưa vào danh sách cấm 1 số biểu thức, nhưng với eval thì với những biểu thức như vậy thì không vấn đề gì?\nHàm đầu tiên mà safe_eval đưa vào danh sách cấm là import. Mình có 1 ví dụ ở dưới đây:\nmy_string = \u0026quot;__import__('odoo').tools.float_round(a/b,pricision)\u0026quot; Nhưng đối với eval biểu thức trên lại không gây ra lỗi như sau:\neval_value = eval(my_string, {'a': 15, 'b': 2, 'pricision': 0}) Nhưng nếu chuyển biểu thức này sang bên safe_eval thì lại gây ra lỗi:\nsafe_eval_value = safe_eval(my_string, {'a': 15, 'b': 2, 'pricision': 0} Sẽ có lỗi như hình dưới đây\nChúng ta cũng có thể thay đổi chế độ safe_eval, theo mặc định khi chúng ta gọi safe_eval, odoo sẽ thực thi module eval của python.\nNhưng chúng ta cũng có thể thay thế module eval bằng 1 module khác, ví dụ như đoạn code dưới đây:\nmy_string = \u0026quot;c = a + b\u0026quot; my_value = {'c': 1} print('my_value==before==', my_value) # my_value==before== {'c': 1} safe_eval(my_string, {'a': 4, 'b': 7}, my_value, mode=\u0026quot;exec\u0026quot;, nocopy=True) print('my_value==after==', my_value) # my_value==after== {'c': 11} Trong trường hợp bạn không rõ, nếu chúng ta truyền biểu thức c = a + b vào module eval, nó sẽ gây ra lỗi bởi vì c = a + b\nkhông phải là 1 biểu thức. Nhưng nếu bản truyền mode=\u0026ldquo;exec thì đoạn code trên sẽ không gây ra lỗi. Nhưng với mode=\u0026ldquo;exec\u0026rdquo;\nthì sẽ không trả về giá trị, do đó chúng ta phải truyền vào đối số thứ 3 là biến my_value để lưu trữ giá trị tính toán.\nLưu ý chút là nếu như bạn gọi module safe_eval ở chế độ thực thi, chúng ta phải đặt giá trị của đối số no_copy = True, nếu không\ngiá trị my_value sẽ không thay đổi.\nVậy, trong Odoo safe_eval được sử dụng chính để làm gì?.\nĐầu tiên safe_eval được sử dụng để đánh giá, validate 1 miền chuỗi. Ví dụ trong module pos_loyalty trong odoo 14 enterprise. Hoặc trong\nmodule mình có viết ở đây để giới hạn động quyền truy cập nút in.\nTrong module này mình có viết 1 field là condition với kiểu dữ liệu là Char, trong view mình cho hiển thị lên trường này với\nwidget là domain mặc định của odoo. Widget này cho mọi người viết domain một cách dễ dàng và domain người dùng nhập vào vẫn được lưu dưới dạng Char\nBởi vì tên miền được lưu dưới dạng Char trong cơ sở dữ liệu, nên tất nhiên chúng ta không thể chuyển tên miền trực tiếp đến phương thức tìm kiếm hoặc\nbất kỳ mật phương thức vào khác được. Vì vậy chúng ta phải thay đổi nó thành 1 domain hợp lệ là 1 List, chúng ta có thể sử dụng điều này bằng cách sử\ndụng safe_eval. Tuy nhiên đối với Odoo, cách convert từ string qua List cũng không nhất quán, như ở trong module coupon việc này\nsử dụng bởi module ast cũng là một module có sẵn trong python.\nMột trường hợp khác mà Odoo sử dụng safe_eval đó là việc tính toán báo cáo lãi lỗ và bảng cân đối kế toán trong Odoo enterprise. Bạn có thể\ntìm thấy nó theo Kế toán \u0026raquo; Cấu hình \u0026raquo;\u0026gt; Báo cáo tài chính \u0026raquo; Lãi lỗ\nMình sẽ ví dụ thêm như sau:\nmy_string = 'S00006 + S00007' Chúng ta sẽ sử lý chuỗi này, lấy nó ra để tính toán cũng như tìm kiếm. Đầu tiên mình sẽ tạo ra 1 class được kế thừa từ lớp Dict\nclass DataSet(dict): def __init__(self, model, field_to_search, field_to_calculate): super().__init__() self.model = model self.field_to_search = field_to_search self.field_to_calculate = field_to_calculate def __getitem__(self, item): record = self.model.search([(self.field_to_search,'=',item)],limit=1) if record: return getattr(record, self.field_to_calculate) else: return 0 Sau đó khi chúng ta gọi safe_eval, chúng ta có thể sử dụng lớp Dataset làm đối số như đoạn code dưới đây\nmy_string = 'S00006 + S00007' value = safe_eval(my_string,DataSet(self.env['sale.order'],'name','amount_total'), nocopy=True) Khi safe_Eval cố gắng lấy giá trị biểu thức, safe_Eval sẽ kích hoạt phương thức get_item_. Đây là lý do chúng ta ghi đè phương thức để này để trả về giá trị động.\nNếu chúng ta sử dụng safe_eval cho các mục đích khác nhau, chẳng hạn như lấy giá trị tổng phụ của đơn hàng, như đoạn code dưới đây:\nmy_string = 'P00006 + P00007' value = safe_eval(my_string,DataSet(self.env['purchase.order'],'name','amount_untaxed'), nocopy=True) Đó là tất cả những gì mình viết về sale_eval, ngay bản thân tên của safe_eval đã chứng minh rằng safe_eval sẽ đưa một số biểu thức vào danh sách đen, mình\nhy vọng khi sử dụng , ứng dụng mình viết có thể an toàn hơn 😄. Bài viết còn nhiều thiếu sót, mong các bạn thông cảm nha.\n","description":"Cách sử dụng safe_eval trong Odoo","id":9,"section":"posts","tags":["Odoo"],"title":"Cách sử dụng safe_eval trong Odoo","uri":"https://hungpt.info/en/posts/safe_eval_in_odoo/"},{"content":"Trong bài viết lần này, chúng ta hãy cùng tìm hiểu 1 hook mới trong ReactJS là useMemo và 1 HOC trong ReactJS là memo nhé!😄\nTrong quá trình làm việc với React, chúng ta sẽ có lựa chọn như:\n Hooks render props higher-order-components (HOCs)  Mình sẽ nói cụ thể hơn 3 phần này khác gì nhau ở bài viết sau nhé 😄\n1. memo trong ReactJS mình có 1 đoạn code đơn giản như sau\nimport {useState} from \u0026quot;react\u0026quot;; import {useEffect} from \u0026quot;react\u0026quot;; import Content from \u0026quot;./Content\u0026quot;; import Chat_content from \u0026quot;./chat_fake/Chat_content\u0026quot;; import UseRef from \u0026quot;./use_ref/UseRef\u0026quot;; import Memo_content from \u0026quot;./memo/Memo_content\u0026quot;; function App() { const [show, setShow] = useState(false) const [number, setNumber] = useState(1) const handleSetnumber = () =\u0026gt; { setNumber(number+1) } return ( \u0026lt;div style={{padding: 32}}\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Memo_content/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; {number} \u0026lt;/div\u0026gt; \u0026lt;button onClick={handleSetnumber}\u0026gt; Click \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; Và đây là code của component Memo_content\nimport {memo, useEffect, useState} from \u0026quot;react\u0026quot;; function Memo_content() { console.log('render') return ( \u0026lt;div\u0026gt; Hello \u0026lt;/div\u0026gt; ) } export default Memo_content; Chúng ta có thể thấy, mỗi khi click đẩ thay đổi state của component cha thì component con là Memo_content cũng được\nrender lại mặc dù component con không có gì thay đổi. Vậy chúng ta sẽ xử lý vấn đề này như thế nào?\nRất đơn giản, bạn chỉ cần thêm memo để wrap lại component con như sau:\nexport default memo(Memo_content); Thông thường với những component nặng về xử lý logic như biểu đồ, dashboard mà chúng ta không muốn render lại\ncomponent thì nên dùng cách này, còn thông thường việc này cũng không quá quan trọng 😄 theo mình là như vậy\n2. useMemo trong ReactJS Vậy khi nào chúng ta sử dụng useMemo? ĐÓ là khi chúng ta không muốn thực hiện lại 1 logic nào đó không cần thiết.\nVậy khi nào là không cần thiết? Chúng ta hãy cùng tìm hiểu qua 1 ví dụ đơn giản mình đưa ra ở dưới đây nhé!\nimport {useState} from \u0026quot;react\u0026quot;; function App() { const [name, setName] = useState('') const [price, setPrice] = useState('') const [products, setProducts] = useState([]) const handleSubmit = () =\u0026gt; { setProducts([...products,{ name, price: +price }]) } const total = products.reduce((result, pro) =\u0026gt; { console.log('bi tinh toan lai') return result + pro.price },0 ) return ( \u0026lt;div style={{ padding: '10px 200px' }}\u0026gt; \u0026lt;input value={name} placeholder='Enter name...' onChange={event =\u0026gt; setName(event.target.value)} /\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input value={price} placeholder='Enter price...' onChange={event =\u0026gt; setPrice(event.target.value)} /\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;button onClick={handleSubmit} \u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; Total : {total} \u0026lt;ul\u0026gt; { products.map((product, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{product.name} - {product.price}\u0026lt;/li\u0026gt; )) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; Về cơ bản ứng dụng đơn giản là như vậy😄\nTuy nhiên nếu như bạn để ý, hàm tính toán ra price của mình luôn bị gọi khi chúng ta nhập\ngiá trị vào ô price, mặc dù khi đó chúng ta chưa cần tính lại total. Và đây là\nlúc chúng ta sử dụng useMemo như sau:\nimport {useState, useMemo} from \u0026quot;react\u0026quot;; function App() { const [name, setName] = useState('') const [price, setPrice] = useState('') const [products, setProducts] = useState([]) const handleSubmit = () =\u0026gt; { setProducts([...products,{ name, price: +price }]) } const total = useMemo(() =\u0026gt; { const total = products.reduce((result, pro) =\u0026gt; { console.log('bi tinh toan lai') return result + pro.price },0 ) },[products]) return ( \u0026lt;div style={{ padding: '10px 200px' }}\u0026gt; \u0026lt;input value={name} placeholder='Enter name...' onChange={event =\u0026gt; setName(event.target.value)} /\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input value={price} placeholder='Enter price...' onChange={event =\u0026gt; setPrice(event.target.value)} /\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;button onClick={handleSubmit} \u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; Total : {total} \u0026lt;ul\u0026gt; { products.map((product, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{product.name} - {product.price}\u0026lt;/li\u0026gt; )) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; Tương tự như useEffect và useCallback, useMemo cũng nhận 2 đối số,\nđối số thứ nhất là 1 callback, đối số thứ 2 là 1 dependencies, nguyên tắc hoạt động\ncủa dependencies cũng tương tự như useEffect và useCallback.\nHy vọng bài viết sẽ giúp ích cho bạn 😀, hẹn gặp lại mọi người ở những bài viết sau.\n","description":"useMemo và memo trong ReactJs.","id":10,"section":"posts","tags":["Javascript","ReactJS"],"title":"Cách sử dụng useMemo và memo trong ReactJS","uri":"https://hungpt.info/en/posts/use_memo_in_reactjs/"},{"content":"Trong bài viết lần này, chúng ta hãy cùng tìm hiểu 1 hook mới trong ReactJS là useRef nhé!😄\nVậy useRef được sử dụng khi nào? Và mục đích sử dụng của hook này là gì?\nĐầu tiên mình sẽ xây dựng 1 ứng dụng đếm ngược đơn giản như sau:\nimport {useState, useEffect, useRef} from \u0026quot;react\u0026quot;; function Content() { const [number, setNumber] = useState(9000) const handle_start = () =\u0026gt; { setInterval(() =\u0026gt; { setNumber(preNumber =\u0026gt; preNumber - 1) },100) } const handle_stop = () =\u0026gt; { } return ( \u0026lt;div\u0026gt; \u0026lt;div style={ {'fontSize': '100px'} }\u0026gt; {number} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button onClick={handle_start} \u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={handle_stop} \u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content; Giao diện đơn giản nó sẽ như thế này 😄\nBài toán mình sẽ đi giải quyết ở đây là sau khi bấm nút stop thì ứng dụng đếm số sẽ ngừng lại tại con số hiện thời. Chúng ta đã setInterval ở button start,\nvậy để stop chúng ta chỉ cần clearInterval ở button stop thôi. Nhưng function clearInterval() nhận đối số truyền vào là ID hiện thời\nCách đơn giản là chúng ta sẽ thêm 1 biến là timeID và truyền cho giá trị mỗi khi setState lại như sau:\nimport {useState, useEffect, useRef} from \u0026quot;react\u0026quot;; function Content() { const [number, setNumber] = useState(9000) let timeId const handle_start = () =\u0026gt; { setInterval(() =\u0026gt; { timeId = setNumber(preNumber =\u0026gt; preNumber - 1) },100) console.log('start', timeId) } const handle_stop = () =\u0026gt; { clearInterval(timeId) console.log('stop', timeId) } return ( \u0026lt;div\u0026gt; \u0026lt;div style={ {'fontSize': '100px'} }\u0026gt; {number} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button onClick={handle_start} \u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={handle_stop} \u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content; Nhưng bài toán vẫn chưa được giải quyết? Chúng ta thử xem log timeID hiển thị trước và sau thế nào nhé!\nVậy là biến timeID không được lưu lại? Tại sao lại như vậy? Đó là bởi vì biến timeID của chúng ta nằm trong component và mỗi khi state thay đổi component\nsẽ render lại dẫn đến biến *** timeID*** sẽ được set lại giá trị lại.\nĐể giải quyết định vấn đề này chúng ta có thể cho biến timeID ra ngoài function component, khi đó, bài toán của chúng ta sẽ được giải quyết\nimport {useState, useEffect, useRef} from \u0026quot;react\u0026quot;; let timeId function Content() { const [number, setNumber] = useState(9000) const handle_start = () =\u0026gt; { timeId = setInterval(() =\u0026gt; { setNumber(preNumber =\u0026gt; preNumber - 1) },1000) console.log('start', timeId) } const handle_stop = () =\u0026gt; { clearInterval(timeId) console.log('stop', timeId) } return ( \u0026lt;div\u0026gt; \u0026lt;div style={ {'fontSize': '100px'} }\u0026gt; {number} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button onClick={handle_start} \u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={handle_stop} \u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content; Tuy nhiên với ReactJS chúng ta không nên làm thế 😄 có nhiều nguyên nhân\u0026hellip;\u0026hellip;nên ở đây chúng ta sẽ sử dụng useRef.\nKhi chúng ta dùng useRef để lưu giá trị, thì khi phải render lại một function component, giá trị đã lưu sẽ không bị thay đổi, mà vẫn giữ được giá trị đã lưu trước đó.\n useRef(initialValue) chấp nhận đối số là giá trị đầu vào và trả về một tham chiếu. Tham chiếu là một object đặc biệt có 1 thuộc tính là current: reference.current Có 2 điều cần nhớ về useRef là:  Gía trị của reference sẽ được giữ nguyên khi component re-render Việc update reference sẽ không làm cho component re-render   Tới đây có thể thấy useRef() khá giống với state trong việc save 1 value, nhưng điểm khác nhau là khi set lại state thì\ncomponent re-render, còn với useRef() thì không. Một điểm nữa là state update sẽ chạy bất đồng bộ, còn với useRef() sẽ update ngay lập tức vì được chạy đồng bộ.  Mình sẽ sửa lại code sử dụng useRef như sau:\nimport {useState, useEffect, useRef} from \u0026quot;react\u0026quot;; function Content() { const [number, setNumber] = useState(9000) const ref = useRef(99) let timeId = useRef(99) const handle_start = () =\u0026gt; { timeId.current = setInterval(() =\u0026gt; { setNumber(prevNumber =\u0026gt; prevNumber - 1) }, 1000) console.log('start', timeId.current) } const handle_stop = () =\u0026gt; { clearInterval(timeId.current) console.log('stop', timeId.current) } return ( \u0026lt;div\u0026gt; \u0026lt;div style={ {'fontSize': '100px'} }\u0026gt; {number} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button onClick={handle_start} \u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button onClick={handle_stop} \u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content; Lưu ý: Hạn chế việc sử dụng useRef mà thay vào đó nên sử dụng state, chỉ khi không thể sử dụng được state thì mới dùng useRef(), như trường hợp tuy cập DOM.\nHi vọng bài viết sẽ giúp ích được các bạn hiểu rõ hơn khi nào thì sử dụng nó và áp dụng vào từng trường hợp cụ thể. Nếu có bất kì thắc mắc hay góp ý nào xin comment phía dưới. Mình xin cảm ơn!\n","description":"UseRef trong ReactJs.","id":12,"section":"posts","tags":["Javascript","ReactJS"],"title":"Cách sử dụng useRef trong ReactJS","uri":"https://hungpt.info/en/posts/use_ref/"},{"content":"Nội dung ở phần này mình muốn đưa cho các bạn sẽ có 3 phần chính:\n Cách listen DOMEvent trong React component Vấn để xảy ra khi chúng ta listen DOM Event là gì? Cách khắc phục vấn đề nàymột  Trong phần này, chúng ta phải nắm vững kiến thức Javascript cơ bản đó là listen DOM Event bạn có thể tham khảo tài liệu tại đây Listen DOM Event\nMình sẽ xác định rõ ngay từ đầu là khi thực hiện một logic mới, chúng ta sẽ viết ra 1 useEffect mới\nBây giờ chúng ta sẽ làm 1 ví dụ, đó là khi chúng ta cuộn chuột xuống 1 khoảng lớn hơn hoặc = 200 px thì sẽ hiện 1 nút Go to top\nđể hiện lên trang đầu, như trong blog này của mình cũng có tính năng này.\nỞ trường hợp này chúng ta sẽ đi listenDOM 1 lần, khi đó chúng ta sẽ truyền dependencies vào là []\nuseEffect(() =\u0026gt; { const handleScroll = () =\u0026gt;{ console.log(window.scrollY) } window.addEventListener('scroll', handleScroll) }, []) ở đây chúng ta sẽ code Javascript thuần, để có thể ẩn hiện được button go to top, chúng ta cần phải re render lại giao diện, với ReactJs chúng ta sẽ dùng hoook\nuseState mà chúng ta đã tìm hiểu ở các phần trước.\nfunction Content() { const [title, setTitle] = useState('') const [posts, setPosts] = useState([]) const [types, setTypes] = useState(['posts']) const [showGoToTop, setShowGoToTop] = useState(false) useEffect( () =\u0026gt;{ console.log('title changed') document.title = title; fetch(`https://jsonplaceholder.typicode.com/${types}`) .then(res =\u0026gt; res.json()) .then(posts =\u0026gt;{ setPosts(posts) }) },[types] ) useEffect(() =\u0026gt; { const handleScroll = () =\u0026gt;{ if(window.scrollY \u0026gt;= 200){ setShowGoToTop(true) }else{ setShowGoToTop(false) } } window.addEventListener('scroll', handleScroll) }, []) Sau đó mình sẽ viết 1 đoạn code để ẩn hiện button go to top theo state bên trên\n {showGoToTop \u0026amp;\u0026amp; ( \u0026lt;button style={{ position: 'fixed', right: 20, bottom: 20 }}\u0026gt; Go to top \u0026lt;/button\u0026gt; )} Và kết quả sẽ như sau:\nTuy nhiên nếu các bạn để ý thì chúng ta sẽ thấy rằng, nếu chúng ta tiếp tục kéo chuột xuống thì useEffect sẽ liên tục được gọi\ndẫn tới việc liên tục re render lại giao diện? Câu trả lời là không, ReactJS đã giúp chúng ta ngăn chặn việc đó. Có nghĩ là mặc dù hàm trong useEffect được gọi lại liên tục nhưng\ncomponent sẽ không bị re render lại.\nĐến với 1 vấn đề tiếp theo, bây giờ chúng ta thử unmount component rồi mount lại, xong đó kéo chuột xuống, sẽ có 1 thông báo mà ReactJS báo cho chúng ta như sau:\nĐó là bởi vì khi component của chúng ta unmount thì Event Listen chúng ta thêm vào chưa được xóa đi, dẫn tới việc khi chúng ta mount lại component thì 1 event\nlisten nữa lại được thêm vào, điều này dẫn đến lãng phí tài nguyên, dò rỉ bộ nhớ. Vậy giải pháp ở đây là gì? Đó chính là Cleanup Function và trong callback\ncủa useEffect các bạn có thể return ra 1 hàm\nuseEffect(() =\u0026gt; { const handleScroll = () =\u0026gt;{ if(window.scrollY \u0026gt;= 200){ setShowGoToTop(true) }else{ setShowGoToTop(false) } } window.addEventListener('scroll', handleScroll) // cleanup function return () =\u0026gt; window.removeEventListener('scroll', handleScroll) }, []) Hy vọng sau phần này bạn sẽ nắm rõ cách xử lý DOM event trong Reactjs 😄. Bye bye\n","description":"UseEffect với DOMEvent .","id":13,"section":"posts","tags":["Javascript","ReactJS"],"title":"Cách sử dụng useEffect trong ReactJS (Phần 3)","uri":"https://hungpt.info/en/posts/use_effect_part3/"},{"content":"Ở phần này, mình sẽ xây dựng app chat đơn giản để có thể giúp các bạn nắm rõ hơn cách sử dụng useEffect như thế nào nhé!😄\nỞ đây mình sẽ không tạo web socket server mà mình sẽ đi fake ra những bình luận\n","description":"UseEffect với Timer function.","id":14,"section":"posts","tags":["Javascript","ReactJS"],"title":"Cách sử dụng useEffect trong ReactJS (Phần 4)","uri":"https://hungpt.info/en/posts/use_effect_part4/"},{"content":"Trong bài viết lần này chúng ta sẽ cùng hiểu 2 thuật ngữ Mount và Unmount. Trong đó Mount có nghĩa là gắn vào, Unmount\nnghĩa là tháo ra gỡ ra.\nĐây là 2 thuật ngữ chúng ta sẽ dùng rất nhiều khi làm việc với Reactjs, cụ thể làm làm việc với component.\nĐể ví dụ cho các bạn về 2 thuật ngữ này mình sẽ tạo ra một component được viết trong file Content.js như sau:\nfunction Content() { return ( \u0026lt;h1\u0026gt; Xin chao \u0026lt;/h1\u0026gt; ) } export default Content Sau đó mình sẽ thêm component Content này vào file App.js như sau:\nimport Content from \u0026quot;./Content\u0026quot;; function App() { return ( \u0026lt;div style={{padding: 32}}\u0026gt; \u0026lt;Content/\u0026gt; \u0026lt;/div\u0026gt; ) } export default App; Bây giờ mình sẽ thêm 1 state vào để quyết định việc ẩn hiện của component Content này,sau đó thêm 1 button click để ẩn hiện nó\nimport {useState} from \u0026quot;react\u0026quot;; import Content from \u0026quot;./Content\u0026quot;; function App() { const [show,setShow] = useState(false) return ( \u0026lt;div style={{padding: 32}}\u0026gt; \u0026lt;button onClick={()=\u0026gt;setShow(!show)}\u0026gt; Click \u0026lt;/button\u0026gt; {show \u0026amp;\u0026amp; \u0026lt;Content/\u0026gt;} \u0026lt;/div\u0026gt; ) } export default App; Để dễ hình dung hơn, mình có hình dưới đây\nKhi chúng ta click vào button, dòng \u0026lt;h 1\u0026gt; Xin chao \u0026lt;/h 1\u0026gt; sẽ được mount và unmount vào trong DOM. Thực chất mình lấy ví dụ trong DOM là cho các bạn dễ hình dung\nthực ra element cho tới khi được render vào DOM thì thật ra là bước sau của mount rồi 😄.\nHành vi Mount và Unmount được diễn ra trước đó rồi, thì tại sao lại như vậy? Đó là vì khi chúng ta click button, function App\nsẽ được chạy lại, khi biến show = True thì component Content được gọi, thì tại thời điểm component Content được đưa vào React Element để\nsử dụng thôi thì quá trình Mount đã xảy ra ngay thời điểm này rồi.\nChú ý nhỏ : thực ra ngay bản thân App.js cũng đã được Mount khi chúng ta f5 trình duyệt đó 😄 bạn thử tìm hiểu thêm tại sao lại như vậy nha.\n","description":"Mounted \u0026 Unmounted?","id":15,"section":"posts","tags":["Javascript"],"title":" Mounted \u0026 Unmounted? ","uri":"https://hungpt.info/en/posts/placeholder-text/"},{"content":"useEffect là 1 hook cơ bản trong Reactjs, nhưng khi bạn mới học sẽ thấy nó hơi khó một chút😁. Lý do nó khó không phải vì hook\nnày nó khó mà vì để có thể sử dụng được hook này đòi hỏi bạn phải nắm vững kiến thức Javascript cơ bản và nâng cao. Thế nên\nnếu bạn đi vào đây học quá nhanh hoặc quên mất kiến thức nền thì học sẽ bị khó.\nỞ đây mình sẽ review cho bạn một số kiến thức mà bạn nên nắm chắc khi học hook này:\n Events : Bạn nên biết cách làm việc với event trong javascript, bao gồm cả Dom event và custom event do bạn tạo ra, biết cách\nsử dụng add/remove event listener, hiểu tại sao phải remove event listener Observer parttern : (Subscribe/unsubcribe) Đây là 1 dạng triển khai mở rông của tư tưởng add/remove listener, bản chất cũng là dạng\nđầu tiên nhưng triển khai ở 1 dạng khác Bạn cần nắm rõ khái niệm hàm đóng Closure trong Javascript. Biết cách làm việc với api dạng timer như setInterval, setTimeout, clearInterval, ClearTimeout. Nắm chắc hook useState. Hiểu rõ khi nào mounted, khi nào unmounted.  Hook này để làm gì và chúng ta dùng nó khi nào? Chúng ta sẽ dùng useEffect khi các bạn muốn thực hiện các side effect, thuật ngữ này được sử dụng chung trong lĩnh vực phần mềm,\nside effect đang nói tới 1 chương trình phần mềm khi có 1 tác động xảy ra dẫn đến dữ liệu bị thay đổi. Mình sẽ đưa\ncho bạn một vài ví du quen thuộc để bạn dễ hình dung đó là khi bạn update DOM, call api nhận lại dữ liệu để setState\u0026hellip;.\nTóm lại useEffect sẽ giúp các bạn update DOM, call API, listen DOM event, remove event listener\u0026hellip;\nuseEffect có 3 tình huống chính khi chúng ta sử dụng:\n useEffect(callback) useEffect(callback,[]) useEffect(callback,[deps])  Hãy cùng mình đi tìm hiểu từng tình huống và xem cách useEffect hoạt động như thế nào nhé!\n1. useEffect(callback) Với trường họp này, callback sẽ được gọi mỗi khi component được mounted vào trong DOM\nimport {useState} from \u0026quot;react\u0026quot;; import { useEffect } from \u0026quot;react\u0026quot;; import Content from \u0026quot;./Content_blog\u0026quot;; function App() { const [show,setShow] = useState(false) return ( \u0026lt;div style={{padding: 32}}\u0026gt; \u0026lt;button onClick={()=\u0026gt;setShow(!show)}\u0026gt; Click \u0026lt;/button\u0026gt; {show \u0026amp;\u0026amp; \u0026lt;Content/\u0026gt;} \u0026lt;/div\u0026gt; ) } export default App; import { useEffect } from \u0026quot;react\u0026quot;; import {useState} from \u0026quot;react\u0026quot;; function Content() { const [title, setTitle] = useState('') useEffect(() =\u0026gt; { console.log('test12') }); return ( \u0026lt;div\u0026gt; \u0026lt;input value={title} onChange={(e)=\u0026gt; setTitle(e.target.value)} z /\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content ở đây mình có viết 1 useEffect mỗi khi mình click button thì ô input sẽ được hiển thị\nNhư bạn có thể thấy mỗi khi click button, component sẽ được render lại =\u0026gt; dẫn tới việc callback trong trường hợp useEffect\nnày sẽ được gọi lại, bạn có thể thấy log bên dưới tab console.\nTuy nhiên trường hợp đầu tiên này được sử dụng khá ít trong thực tế và khi sử dụng trường hợp này để call API update lại DOM cũng sẽ xảy ra một điều 😃 cùng mình\nxem đó là gì nhé!\nBây giờ mình sẽ call 1 api và update DOM, api mình sẽ lấy ở https://jsonplaceholder.typicode.com.\nimport { useEffect } from \u0026quot;react\u0026quot;; import {useState} from \u0026quot;react\u0026quot;; function Content() { const [title, setTitle] = useState('') const [posts, setPosts] = useState([]) useEffect( () =\u0026gt;{ fetch('https://jsonplaceholder.typicode.com/posts') .then(res =\u0026gt; res.json()) .then(posts =\u0026gt;{ setPosts(posts) }) } ) return ( \u0026lt;div\u0026gt; \u0026lt;input value={title} onChange={(e)=\u0026gt; setTitle(e.target.value)} z /\u0026gt; \u0026lt;ul\u0026gt; {posts.map(post =\u0026gt;( \u0026lt;li key={post.id}\u0026gt;{post.title}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content Có vẻ mọi thứ đã hoạt động rồi nhỉ, tuy nhiên bạn hãy cũng nhìn tab network với mình nhé!\nAPI được gọi liên tục trong 1 vòng lặp vô hạn. Tại sao lại như vậy? Đó chính là khi gọi API xong, chúng ta gọi lại hàm setPost(), dẫn tới việc component\nđược render lại và rồi theo như lý thuyết của useEffect là callback sẽ được gọi mỗi khi component được mounted vào trong DOM dẫn tới việc xảy ra vòng lặp\nvô hạn ở đây. Chính điều này là nguyên nhân mà chúng ta cần sử dụng useEffect với 2 trường hợp còn lại hoặc còn gọi chung là useEffect với dependencies.\n","description":"Cách sử dụng useEffect trong Reactjs .","id":16,"section":"posts","tags":["Javascript","ReactJS"],"title":"Cách sử dụng useEffect trong Reactjs (Phần 1)","uri":"https://hungpt.info/en/posts/use_effect/"},{"content":"Ở phần 1, chúng ta đã tìm hiểu về trường hợp đầu tiên sử dụng useEffect, cùng hiểu tại sao phải sử dụng tham số thứ 2 trong useEffect. Trong\nphần này chúng ta sẽ tìm hiểu rõ hơn.\nĐể có thể xử lý vấn đề api call liên tục k dừng ở phần 1, bạn chỉ cần thêm tham số thứ 2 trong useEffect có thể là 1 mảng rỗng []\nhoặc 1 mảng có giá trị [post\u0026hellip;]\nuseEffect( () =\u0026gt;{ fetch('https://jsonplaceholder.typicode.com/posts') .then(res =\u0026gt; res.json()) .then(posts =\u0026gt;{ setPosts(posts) }) },[] ) Vậy trong trường hợp dependency array không phải mảng rỗng thì sao?\nNếu mảng này có phần tử, mỗi khi giá trị của phần tử thay đổi, call back của useEffect sẽ được gọi lại. Ví dụ trong đoạn code này mình sẽ sửa lại 1 chút như sau:\nimport { useEffect } from \u0026quot;react\u0026quot;; import {useState} from \u0026quot;react\u0026quot;; const tabs = ['posts','comments','albums'] function Content() { const [title, setTitle] = useState('') const [posts, setPosts] = useState([]) const [types, setTypes] = useState(['posts']) useEffect( () =\u0026gt;{ console.log('title changed') document.title = title; fetch(`https://jsonplaceholder.typicode.com/${types}`) .then(res =\u0026gt; res.json()) .then(posts =\u0026gt;{ setPosts(posts) }) },[types] ) return ( \u0026lt;div\u0026gt; {tabs.map(tab =\u0026gt; ( \u0026lt;button style={types ===tab ? { color : '#fff', backgroundColor : 'black' } : { coler : 'fff', backgroundColor : 'blue' }} key={tab} onClick={() =\u0026gt;setTypes(tab)} \u0026gt;{tab}\u0026lt;/button\u0026gt; ))} \u0026lt;input value={title} onChange={(e)=\u0026gt; setTitle(e.target.value)} z /\u0026gt; \u0026lt;ul\u0026gt; {posts.map(post =\u0026gt;( \u0026lt;li key={post.id}\u0026gt;{post.title}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default Content Mình đã thêm 3 button, khi click vào từng button sẽ gọi API tương ứng, để có thể làm được điều này mình đã thêm 1 state là types, mỗi\nkhi click vào từng button, mình sẽ dùng useState để set lại giá trị tương ứng, khi có giá trị rồi mình sẽ truyền vào API để call.\nNhư vập sau khi giá trị của types thay đổi, callback của useEffect sẽ được gọi lại.\nỞ phần tiếp theo chúng ta sẽ tìm hiểu về useEffect với listen DOMEvent nhé! 😃\n","description":"UseEffect với dependencies trong Reactjs .","id":17,"section":"posts","tags":["Javascript","ReactJS"],"title":"Cách sử dụng useEffect trong Reactjs (Phần 2)","uri":"https://hungpt.info/en/posts/use_effect_part2/"},{"content":"Gỉa sử chúng có một mảng các chữ số như sau:\nconst numbers = [2, 4, 6]; Làm sao chúng ta có thể tính tổng các chữ số trong mảng trên. Sử dụng reduce trong javascript chúng ta có dễ dàng làm việc này mà không cần sử dụng vòng lặp.\nconst numbers = [2, 4, 6]; const sum = numbers.reduce(function(sum, number) { const updatedSum = sum + number; return updatedSum; }, 0); sum; // 12 Trong bài viết này, chúng ta sẽ tìm hiểu về phương thức reduce và cách sử dụng array.reduce(callback, initialValue)\n1.Phương thức reduce Trước khi đi sâu hơn về cách sử dụng array.reduce() chúng ta hãy cùng tìm hiểu reduce được sử dụng làm mục đích gì? Đó chính là giảm kích thước của 1 mảng thành\n1 giá trị duy nhất.\nMột ví dụ khác của việc này là xác đinh phần từ lớn nhất của mảng [7,2,10,6] kết quả ở đây sẽ là 10.\nQua đó chúng ta có thể thấy được rằng phương thức reduce() mục đích là để thực hiện thao tác rút gọn phần tử trong mảng.\n2.Array.reduce() Array.reduce() có 2 đối số truyền vào:\nconst value = array.reduce(callback[, initialValue]); Trong đó callback là đối số bắt buộc, initialValue không bát buộc và làm giá trị khởi tạo.\nJavascript gọi callback trên mỗi phần tử của mảng với 4 đối số (giá trị tích lũy, phần tử hiện tại của mảng, index của phần tử hiện tại trong mảng, mảng chính)\narray.reduce(function(accumulator, item, index, array) { // Use `accumulator` and `item` // to calculate `updatedAccumulator`... return updatedAccumulator; }) Một ví dụ cụ thể hơn:\nconst numbers = [2, 4, 6]; const sum = numbers.reduce(function summarize(sum, number) { const updatedSum = sum + number; return updatedSum; }, 0); sum; // 12 numbers.reduce(summarize, 0) dùng để tính tổng tất cả các phần tử trong mảng\nNgoài ra hãy lưu ý đối số thứ 2 numbers.reduce(summarize, 0) đó là tổng các phần tử trong mảng được gán mặc định ban đầu là 0.\nVậy làm cách nào để tìm phần tử lớn nhất trong mảng khi chúng ta sử dụng reduce()? Bạn hãy tìm hiểu xem sao nhé? 😄\n3. Bỏ qua giá trị khởi tạo ban đầu (initialValue) Giá trị này sẽ được khởi tạo cho previousValue ở lần thực thi đầu tiên. Nếu bạn truyền 1 initialValue thì currentValue sẽ được khởi tạo là giá trị đầu tiên của mảng.\nNếu không truyền initialValue thì previousValue được khởi tạo là giá trị đầu của mảng và vì thế currentValue sẽ là giá trị thứ hai của mảng.\nĐể dễ hiểu hơn thì chúng ta cùng xem một ví dụ:\n[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, currentIndex, array) { return previousValue + currentValue // 10 }) Đếm số lần xuất hiện phần tử trong mảng Một cách để đếm số lần xuất hiện của phần tử khá hay chính là dùng reduce 😁.\nlet names = ['John', 'Bob', 'Jonas', 'Bruce', 'John'] let count = names.reduce(function (allNames, name) { if (name in allNames) allNames[name]++ else allNames[name] = 1 return allNames }, {}) // { 'John': 2, 'Bob': 1, 'Jonas': 1, 'Bruce': 1 } ","description":"","id":18,"section":"posts","tags":["Javascript"],"title":"Tìm hiểu về phương thức Reduce trong Javascript","uri":"https://hungpt.info/en/posts/javascript-array-reduce/"},{"content":"Trong phần 1, chúng ta đã tạo ra 1 Widget để hiển thị một đoạn text văn bản. Sang phần 2 này, chúng ta cùng nhau xây dựng một logic cho widget này.\nTiếp theo bạn cần khai báo 1 trường như sau:\nfield_one = fields.Integer('Field One') Thông thường khi chúng ta khai báo 1 field như trên và thêm chúng vào XML, mặc định Odoo sẽ cho chúng ta sửa giá trị trên giao diện kiểu như sau:\nNhưng để có thể hạn chế thêm việc người dùng nhập vào không phải ký tự là số nguyên, ở đây mình sẽ thêm 2 nút tăng giảm + - và trường giá trị để readonly.\nDưới đây là đoạn code:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;template\u0026gt; \u0026lt;t t-name=\u0026quot;WidgetOneTemplate\u0026quot;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;t t-if=\u0026quot;widget.mode == 'edit' \u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;input-group\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;input-group-prepend\u0026quot;\u0026gt; \u0026lt;button class=\u0026quot;btn btn-danger btn-minus\u0026quot;\u0026gt; - \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; class=\u0026quot;form-control\u0026quot; t-att-value=\u0026quot;widget.value\u0026quot; disabled=\u0026quot;disabled\u0026quot; /\u0026gt; \u0026lt;div class=\u0026quot;input-group-append\u0026quot;\u0026gt; \u0026lt;button class=\u0026quot;btn btn-success btn-plus\u0026quot;\u0026gt; + \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;t t-if=\u0026quot;widget.mode == 'readonly' \u0026quot;\u0026gt; \u0026lt;span t-esc=\u0026quot;widget.value\u0026quot; /\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/template\u0026gt; Trong form ở chế độ chỉnh sửa sẽ như sau:\nSau đó, ở file widget_one.js mình sẽ tiến hành thêm event với 2 button là +-, dưới đây là đoạn code:\nvar WidgetOne = AbstractField.extend({ template: 'WidgetOneTemplate', // fill with the template name that will be rendered by odoo events: { // list of event, like jquery event 'click .btn-minus': 'btn_minus_action', 'click .btn-plus': 'btn_plus_action', }, btn_minus_action: function(){ var new_value = this.value - 1; this._setValue(new_value.toString()); console.log(this.value); }, btn_plus_action: function(){ var new_value = this.value + 1; this._setValue(new_value.toString()); console.log(this.value); }, }); Các odoo viết sự kiện trong js cũng gần giống như jquery chỉ có điều là hơi đảo ngược 1 chút. Đối với jquery chúng ta sẽ viết như sau:\n$('.btn-minus.').click(btn_minus_action); Thực tế chúng ta có thể sử dụng Jquery để thay thế cho đoạn code phía trên, tuy nhiên theo cá nhân mình thấy thì sử dụng code của Odoo sẽ dễ hiểu hơn.\nTuy nhiên nếu có cơ hội mình sẽ chia sẻ thêm về vấn đề này(cũng không phải là không có cách😄)\nĐể có thể thay đổi giá trị của field chúng ta có thể dùng phương thức this._setValue(new_value), nhưng chú ý kiểu dữ liệu của new_value, trong ví dụ của chúng ta\nbiến mà chúng ta truyền vào hàm _setValue phải là string. Thực ra mặc định không hẳn vậy, ví dụ khi chúng ta nhập giá trị vào ô input là 12345678, odoo hiểu ở đây là 1\nchuỗi string và tự động chuyển sang integer để cộng trừ nhân chia.\nVới đoạn code trên chúng ta cần chú ý toString(), tại sao chúng ta lại cần ép kiểu về string? Lý do mình đã giải thích bên trên, đơn giản là chúng ta cần phải ép kiểu\nvề như vậy\nOh, nhưng khoan đã! Tại sao giá trị field của chúng ta vẫn là 0 và không hề thay đổi.\nĐiều này chỉ ra rằng, khi chúng ta thực hiện thay đổi giá trị của field thì giao diện không tự động render lại.\nĐể có thể làm được điều này chúng ta cần phải override lại phương thức _render hoặc _renderEdit. Trong ví dụ của chúng ta, mình sẽ override lại hàm _render.\nCó nhiều cách để thay đổi giao diện người dùng (mình sẽ đề cập trong 1 bài viết sớm), tuy nhiên ở đây mình sẽ dùng qweb và viết nó vào trong hàm _render như sau:\nodoo.define('tutorial_javascript.widget_one', function (require) { \u0026quot;use strict\u0026quot;; var AbstractField = require('web.AbstractField'); var FieldRegistry = require('web.field_registry'); var core = require('web.core'); var qweb = core.qweb; var WidgetOne = AbstractField.extend({ template: 'WidgetOneTemplate', events: { 'click .btn-minus': 'btn_minus_action', 'click .btn-plus': 'btn_plus_action', }, btn_minus_action: function(){ var new_value = this.value - 1; this._setValue(new_value.toString()); }, btn_plus_action: function(){ var new_value = this.value + 1; this._setValue(new_value.toString()); }, _render: function () { console.log(this.value); this.$el.html($(qweb.render(this.template, {'widget': this}))); }, }); FieldRegistry.add('widget_one', WidgetOne); return WidgetOne; }); Tham số đầu tiên mà mình truyền vào qweb.render() đó là template mà chúng ta muốn render lại, tham số thứ 2 ở đây chính là widget của chúng ta, khi thay đổi giá trị của field\n,ở đây là widget do chúng ta đã viết nó trong xml như bên dưới:\nRestart Odoo, refresh trình duyệt chúng ta thấy rằng mọi thứ đã chạy chính xác!\nĐây là phần hai trong loạt bài Javascript trong Odoo, hy vọng bài viết sẽ giúp ích cho bạn 😀\n","description":"","id":19,"section":"posts","tags":["Odoo","Javascript"],"title":"(Javascript trong Odoo) Phần 2 Tạo logic cho widget","uri":"https://hungpt.info/en/posts/odoo-javascript-programming-tutorial-part-two-widget-logic/"},{"content":"Đối với lập trình viên odoo, Widget là một thứ khá mới mẻ bởi vì chúng ta hiếm khi lập trình với ngôn ngữ javascript.\nHầu như tất cả logic được viết với python, ngoại trừ khi tùy chỉnh điểm bán hàng(POS) hoặc mô-đun thương mại điện tử(Website).\nĐối với những lập trình viên odoo, theo cá nhân mình thấy thì javascript là phần cuối cùng mà bạn nên học. Tốt hơn hết bạn nên lập trung code với python\ntrừ khi dự án bạn làm liên quan đến POS hoặc Website\nĐối với odoo có 3 lĩnh vực chính mà javascript đc sử dụng, đó là POS, Website và Front-End.\nLưu ý : Phiên bản Odoo trong bài viết là Odoo13, với các phiên bản khác có thể sẽ không hoạt động ổn định.\nNhìn chung bạn không cần có quá nhiều kiến thức để bắt đầu với Widget, chỉ cần nắm vững được Javascript và Jquery. Javascript trong Odoo\nđược viết chủ yếu trong web/static/src/js/. Bạn có thể tham khảo tại đây odoo github page.\nTrong bài hướng dẫn đầu tiên này, mình sẽ tạo 1 Widget. Widget là 1 thành phần của Odoo, nó được dùng để hiển thị giá trị của một trường trong cơ sở dữ liệu. Ví dụ\nMany2many mặc định sẽ hiển thị dạng bảng, nhưng khi chúng ta sử dụng many2many_tags, dữ liệu sẽ hiển thị dạng từng component con một.\nĐể tạo một Widget, trước tiên bạn phải tạo 1 file javascript. Như ở đây, mình tạo 1 file là widget_one.js và lưu trữ tại thư mục your_module_name/static/src/js/.\nTrước tiên bạn phải chắc chắn widget_one.js đã được load trong odoo bằng câu lệnh sau:\nconsole.log('hello world !'); Tiếp theo chúng ta phải khai báo file javascript này trong một file xml là asset.xml (tên có thể tùy chỉnh)\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;data\u0026gt; \u0026lt;template id=\u0026quot;tutorial_javascript_assets_backend\u0026quot; inherit_id=\u0026quot;web.assets_backend\u0026quot; name=\u0026quot;assets backend\u0026quot;\u0026gt; \u0026lt;xpath expr=\u0026quot;script[last()]\u0026quot; position=\u0026quot;after\u0026quot;\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/tutorial_javascript/static/src/js/widget_one.js\u0026quot;/\u0026gt; \u0026lt;/xpath\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/odoo\u0026gt; Mục đích của việc này là kế thừa lại template web.assets_backend để khai báo thêm file javascipt của chúng ta. Điều này\nsẽ không ảnh hưởng đến phần javascipt phía module POS và module Website thương mại điện tử.\nSau đó thêm file xml phía trên vào file manifest.py, và khởi động lại service odoo, cài đặt module. Sau khi làm mới trình duyệt, F12 mở tab console bạn sẽ thấy như sau:\nTiếp theo khi mọi thứ đã hoạt động, chúng ta sẽ sửa lại file widget_one.js như sau:\nodoo.define('tutorial_javascript.widget_one', function (require) { \u0026quot;use strict\u0026quot;; console.log('Place your widget code here'); }); Lưu ý, tất cả các Widget phải được mở rộng, hoặc là thành phần con của AbstractField cũng như được thêm vào field_registry. Vì vậy chúng ta sẽ viết tiếp như sau:\nodoo.define('tutorial_javascript.widget_one', function (require) { \u0026quot;use strict\u0026quot;; var AbstractField = require('web.AbstractFields'); var FieldRegistry = require('web.field_registry'); }); Trong bài viết này, mình sẽ tạo ra một widget đơn giản để hiện thị một đoạn thông tin ngắn. Để làm được việc này chúng ta có thể ghi đè các phương thức có sẵn như\n_render, _renderEdit, hoặc _renderReadonly.\nĐầu tiên chúng ta tạo 1 template mới với code như sau:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;template\u0026gt; \u0026lt;t t-name=\u0026quot;WidgetOneTemplate\u0026quot;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;t t-if=\u0026quot;widget.mode == 'edit' \u0026quot;\u0026gt; \u0026lt;p\u0026gt;This is the widget view in edit mode (the user is editing the document)\u0026lt;/p\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;t t-if=\u0026quot;widget.mode == 'readonly' \u0026quot;\u0026gt; \u0026lt;p\u0026gt;This is the widget view in readonly mode (the user only sees the document)\u0026lt;/p\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/template\u0026gt; Sau đó khai báo trong manifest.py như sau:\nSau đó mình sẽ viết 1 đoạn code cho widget này:\nodoo.define('tutorial_javascript.widget_one', function (require) { \u0026quot;use strict\u0026quot;; // import các đối tượng cần thiết để tạo widget var AbstractField = require('web.AbstractField'); var FieldRegistry = require('web.field_registry'); // Tạo 1 object với tên tùy chỉnh // đừng quyên kế thừa lại web.AbstractField var WidgetOne = AbstractField.extend({ template: 'WidgetOneTemplate', // template chính là tên template chúng ta khai cái trong file xml }); // đăng ký, nhúng object widget chúng ta vừa tạo vào web.field_registry object // bây giờ chúng ta có thể sử dụng widget odoo's view/xml file // ví dụ với code như dưới đây // \u0026lt;field name=\u0026quot;field_one\u0026quot; widget=\u0026quot;widget_one\u0026quot; /\u0026gt; // the 'widget_one' name is up to you, as long as it's always connected/without spaces FieldRegistry.add('widget_one', WidgetOne); // trả về widget object // vì vậy chúng ta có thể kế thừa hoặc ghi đè trên các module khác return WidgetOne; }); Đây là phần đầu tiên trong loạt bài Javascript trong Odoo, hy vọng bài viết sẽ giúp ích cho bạn 😀\n","description":"","id":20,"section":"posts","tags":["Odoo","Javascript"],"title":"(Javascript trong Odoo) Phần 1 Tạo widget","uri":"https://hungpt.info/en/posts/odoo-javascript-programming-tutorial-part-one-create-widget-view/"},{"content":"Để quản lý State trong React Function Component, chúng ta dùng Hook useState().\nHàm useState trả về 1 mảng 2 phần tử, phần tử đầu tiên là để khởi tạo state, phần tử thứ 2 là hàm để cập nhật state. Tham số truyền vào hàm useState là giá trị khởi tạo của state. Ví dụ:\nKhai báo State Phải khai báo useState ở top level của một Function Component (hoặc một custom Hook), không khai báo ở trong một scope nào khác như vòng lặp, điều kiện, hay function con. Ví dụ khai báo state như sau là sai:\nexport default function App() { function handleClick() { const [count, setCount] = useState(0); // Phải khai báo state ở top-level của Function component } ... } Có thể khai báo nhiều biến state khác nhau. Ví dụ:\nexport default function App() { const [count1, setCount1] = useState(0); const [count2, setCount2] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count1}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{count2}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Cập nhật State Mỗi khi state được cập nhật thì Component sẽ re-render (function được chạy lại và giao diện được cập nhật lại theo state). Cần chú ý là không được thay đổi trực tiếp biến state (immutable) mà phải cập nhật thông qua hàm cập nhật state.\nVí dụ như sau là sai:\nexport default function App() { const [count, setCount] = useState(0); function handleClick() { count++; // Không được thay đổi trực tiếp state như này } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Increase count\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Ví dụ như này là đúng:\nexport default function App() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); // Thay đổi state bằng cách gọi hàm setCount } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Increase count\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Chú ý với các state là array hoặc object thì nên copy giá trị ra 1 biến mới để không làm thay đổi giá trị cũ (pass by reference). Ví dụ:\nexport default function App() { const [arr, setArr] = useState([1, 2, 3]); // Cách sai function addItemToArray1(item) { arr.push(item); // Hàm push làm thay đổi giá trị của state arr setArr(arr); // React không phát hiện có sự thay đổi state nào nên không cập nhật lại giao diện } // Cách đúng function addItemToArray2(item) { setArr([...arr, item]); // Không thay đổi trực tiếp state arr mà tạo ra 1 mảng mới bằng spread syntax } } Cập nhật state sử dụng callback function Thay vì cập nhật state bằng cách truyền vào giá trị mới, thì chúng ta có thể cập nhật state bằng cách truyền vào một hàm callback (có tham số là giá trị cũ) và trả về kết quả là giá trị mới. Ví dụ:\nsetCount((prevCount) =\u0026gt; prevCount + 1); Dùng cách này thì khi cập nhật state sẽ đảm bảo giá trị mới phụ thuộc vào giá trị cũ chứ không phụ thuộc vào giá trị của state ở thời điểm hiện tại. Tham khảo thêm https://reactjs.org/docs/hooks-reference.html#usestate.\nVí dụ với ứng dụng đếm số lượt bấm nút, nếu sửa lại hàm tăng số lượt bấm thành tăng số lượt bấm sau 1 khoảng thời gian (ví dụ 3 giây).\nNếu cập nhật state bằng cách sau thì khi người dùng bấm nút nhiều lần trong khoảng thời gian 3 giây, thì sau 3 giây giá trị của state cũng chỉ tăng lên 1 (lấy giá trị của state ở thời điểm hiện tại cộng thêm 1).\nexport default function App() { const [count, setCount] = useState(0); function handleClick() { setTimeout(() =\u0026gt; { setCount(count + 1); // Thay đổi state dựa theo giá trị của state hiện tại }, 3000); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Increase count after 3 seconds\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Nếu cập nhật state bằng cách truyền vào một hàm thì trong 3 giây delay, người dùng bấm nút bao nhiêu lần thì giá trị của state sẽ tăng lên bấy nhiêu.\nexport default function App() { const [count, setCount] = useState(0); function handleClick() { setTimeout(() =\u0026gt; { setCount((prevCount) =\u0026gt; prevCount + 1); // Thay đổi state dựa theo giá trị của state trước đó }, 3000); } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Increase count after 3 seconds\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Như vậy tùy từng trường hợp mà chúng ta sẽ lựa chọn cách sử dụng sao cho hợp lý.\n","description":"Sử dụng useState() Hook trong React như nào cho đúng?","id":21,"section":"posts","tags":["JavaScript","ReactJS"],"title":"Sử dụng useState() Hook trong React như nào cho đúng?","uri":"https://hungpt.info/en/posts/su-dung-usestate-hook-trong-react-nhu-nao-cho-dung/"},{"content":"ReactJS là một Javascript framework rất phổ biến với giới lập trình Web Frontend hiện nay, số lượng tuyển dụng lập trình viên ReactJS cũng rất lớn. Do đó nhiều người mới học Web Frontend sau khi học xong một chút HTML CSS JS là muốn nhảy vào lập trình ReactJS ngay. Điều này dẫn đến hệ lụy là các bạn sẽ bị hổng kiến thức cơ bản, hoặc khi học ReactJS sẽ rất chật vật vì không hiểu cú pháp, không hiểu bản chất, …\nVậy trước khi học ReactJS hoặc React Native, các bạn nên nẵm vững HTML CSS và những kiến thức sau trong JavaScript (ngoài các kiến thức ban đầu như biến, vòng lặp, điều kiện, …):\n Các hàm xử lý mảng như map, filter, reduce, push, splice, …  ES6/ES7 Class (mặc dù hiện tại code ReactJS đang dần chuyển sang hướng function nhưng vẫn nên biết).\nVariable scope và closure Cần nắm vững khái niệm Scope (code block, nested function, …) trong Javascript. Khai báo biến thì sử dụng let thay cho var (kiểu cũ), với hằng số hoặc magic number thì dùng const.\nKhái niệm closure thì hơi khó hiểu nhưng cũng nên tìm hiểu trước để khi gặp không bị bỡ ngỡ 😅.\nImport và Exports Trong các project chúng ta sẽ có nhiều file để đảm bảo code ngắn gọn và dễ bảo trì. Cần chú ý giữa named export và default export.\nVí dụ /* * File util.js */ // export một mảng export let month = [ \u0026quot;Jan\u0026quot;, \u0026quot;Feb\u0026quot;, \u0026quot;Mar\u0026quot;, \u0026quot;Apr\u0026quot;, \u0026quot;Aug\u0026quot;, \u0026quot;Sep\u0026quot;, \u0026quot;Oct\u0026quot;, \u0026quot;Nov\u0026quot;, \u0026quot;Dec\u0026quot;, ]; // export một hằng số export const YEAR = 2020; // export một class export class User { constructor(name) { this.name = name; } } Arrow function Arrow function được sử dụng khá nhiều bởi cách viết ngắn gọn và không có “this”.\nVí dụ với function thông thường:\nfunction sum(a, b) { return a + b; } Viết lại bằng arrow function:\nconst sum = (a, b) =\u0026gt; a + b; Destructuring assignment Là cú pháp cho phép tách các object, array ra thành các biến, giúp cho code ngắn gọn hơn thay vì khai báo biến nhiều lần. Ví dụ hay sử dụng trong ReactJS:\n// Không sử dụng destructuring assignment function MyComponent(props) { let navigation = props.navigation; let route = props.route; ... } // Sử dụng destructuring assignment function MyComponent({navigation, route}) { ... } Hoặc khi sử dụng useState hook:\nfunction MyComponent() { const [count, setCount] = React.useState(0); } Rest parameters and spread syntax Rest parameters cho phép chúng ta viết 1 hàm với số lượng tham số là linh động (không biết trước). Ví dụ:\nfunction sumAll(...args) { // args là tên biến đại diện cho mảng các tham số let sum = 0; for (let arg of args) sum += arg; return sum; } alert(sumAll(1)); // 1 alert(sumAll(1, 2)); // 3 alert(sumAll(1, 2, 3)); // 6 hoặc:\nfunction showName(firstName, lastName, ...otherNames) { alert(firstName + \u0026quot; \u0026quot; + lastName); // Robin Huy // Rest parameters ...otherNames đại diện cho các tham số còn lại ngoài 2 tham số đầu tiên // ví dụ ở đây otherNames sẽ là [\u0026quot;Robin\u0026quot;, \u0026quot;Huy\u0026quot;] alert(otherNames[0]); // Chris alert(otherNames[1]); // Robert alert(otherNames.length); // 2 } showName(\u0026quot;Robin\u0026quot;, \u0026quot;Huy\u0026quot;, \u0026quot;Chris\u0026quot;, \u0026quot;Robert\u0026quot;); Spread syntax có cú pháp và cách hoạt động gần giống như rest parameters, nó cho phép “duỗi” một object hoặc array ra thành nhiều biến. Ví dụ:\n// Hàm Math.max cần truyền vào các số để tính max alert(Math.max(1, 3, 5, 2)); // Trả về 5 // Tuy nhiên nếu có 1 mảng các số thì chúng ta có thể spread mảng đó ra để sử dụng hàm Math.max const numbers = [1, 3, 5, 2]; alert(Math.max(numbers)); // Trả về NaN alert(Math.max(...numbers)); // Trả về 5 Các hàm xử lý mảng Code ReactJS sẽ phải làm việc với mảng rất nhiều nên phải sử dụng thành thạo các phương thức xử lý mảng như: map, filter, reduce, push, splice, …\nVí dụ sử dụng phương thức map kết hợp arrow function:\nconst numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((number) =\u0026gt; number * 2); Hoặc sử dụng filter để lọc phần tử ra khỏi mảng:\n// Xóa 1 sản phẩm ra khỏi mảng các sản phẩm dựa theo ID truyền vào function removeProduct(productId) { const newProducts = products.filter((product) =\u0026gt; product.id !== productId); setProducts(newProducts); } Trên đây là một vài kiến thức cơ bản mình nghĩ newbie cần phải biết trước khi học ReactJS. Nếu các bạn thấy còn thiếu thì góp ý bổ sung giúp mình ở phần bình luận bên dưới nhé 😘.\n","description":"ReactJS là một Javascript framework rất phổ biến với giới lập trình Web Frontend hiện nay, số lượng tuyển dụng lập trình viên ReactJS cũng rất lớn. Do đó nhiều người mới học Web Frontend sau khi học xong một chút HTML CSS JS là muốn nhảy vào lập trình ReactJS ngay. Điều này dẫn đến hệ lụy là các bạn sẽ bị hổng kiến thức cơ bản, hoặc khi học ReactJS sẽ rất chật vật vì không hiểu cú pháp, không hiểu bản chất, ….","id":22,"section":"posts","tags":["JavaScript","ReactJS"],"title":"Kiến thức Javascript cơ bản cần phải biết trước khi học ReactJS","uri":"https://hungpt.info/en/posts/kien-thuc-javascript-co-ban-can-phai-biet-truoc-khi-hoc-react-native-reactjs/"},{"content":"Không lập trình viên nào code mà không có bug. Tuy nhiên có rất nhiều lỗi cơ bản chúng ta nên tránh để tạo ra ít bug hơn, code sạch và trong sáng hơn, dễ bảo trì hơn, đỡ bị ăn chửi hơn, …\n1. Xử lý quá nhiều thứ trong một function Theo nguyên tắc Single Responsibility, một function chỉ nên thực hiện một và chỉ một nhiệm vụ duy nhất. Nhiều lập trình viên hay viết một function vừa lấy dữ liệu, xử lý dữ liệu và hiển thị dữ liệu. Thay vì như vậy, hãy chia nhỏ function này ra làm 3 function: Function lấy dữ liệu, function xử lý dữ liệu và function hiển thị dữ liệu.\nViệc giữ một function chỉ tập trung thực hiện một nhiệm vụ sẽ giúp code dễ đọc và dễ bảo trì hơn. Như ví dụ trên, giả sử API để lấy dữ liệu bị thay đổi thì ta chỉ cần cập nhật lại function lấy dữ liệu, không bị ảnh hưởng đến các thao tác ở sau.\n2. Code bị comment Trong một ứng dụng lớn có nhiều lập trình viên tham gia, nhiều khi bạn sẽ thấy có các hàm, các đoạn code lớn bị comment. Bạn sẽ không hiểu đoạn code bị comment này để làm gì, ý đồ của tác giả là gì. Các lập trình viên khác có thể sẽ không dám xoá đoạn code này vì có thể tác giả của đoạn comment còn cần đến nó.\nNếu gặp trường hợp như vậy và project có sử dụng hệ thống quản lý code như git, svn, … thì hãy mạnh dạn xoá đoạn code này đi, code sẽ trở nên sạch đẹp hơn. Còn sau này nếu tác giả của đoạn code đó muốn tìm lại thì họ sẽ phải tự tìm trong các commit cũ.\n3. Đặt tên biến, tên hàm không rõ ràng Đặt tên biến là một công việc khó nhưng cũng rất quan trọng. Một tên biến rõ ràng sẽ giúp việc đọc code trở nên dễ dàng, dễ hiểu.\nHãy đặt tên biến mô tả đúng chức năng, ý nghĩa của nó, dài một chút cũng được. Tránh đặt tên biến kiểu viết tắt (trừ trường hợp phổ biến hoặc đã thống nhất từ trước) hoặc tên biến không có ý nghĩa như a, b, c, …\n4. Magic number và string Magic number và string là các giá trị duy nhất được sử dụng nhiều lần trong ứng dụng mà không có giải thích ý nghĩa rõ ràng. Những giá trị này hoàn toàn có thể thay thế bằng các biến (với điều kiện biến phải được đặt tên một cách rõ ràng).\nVí dụ với đoạn code sau:\nfor ($i = 1; $i \u0026lt;= 52; $i++) { ... } Trong ví dụ trên thì 52 là một magic number, và người đọc code sẽ không hiểu được 52 có ý nghĩa là gì. Thậm chí kể cả tác giả đoạn code, sau một thời gian quay lại đọc code của mình cũng không hiểu, phải dò lại toàn bộ chương trình.\nĐoạn code trên có thể viết lại như sau:\n$cardDeckSize = 52; for ($i = 1; $i \u0026lt;= $cardDeckSize; $i++) { ... } Như vậy đọc đoạn code này sẽ hiểu ngay là đang thực hiện một vòng lặp qua từng quân bài trong bộ bài và 52 có nghĩa là số lá bài trong bộ bài. Ở các phần bên dưới cũng có thể dùng lại biến $cardDeckSize và khi cần thay đổi giá trị số lượng lá bài trong bộ bài ta cũng chỉ cần thay đổi giá trị của biến này một lần duy nhất thay vì phải sửa nhiều chỗ.\nTương tự với number, chúng ta cũng có magic string:\n... } và code sẽ trở nên dễ hiểu hơn.\n5. Code format lộn xộn Với những lập trình viên không có kinh nghiệm và cẩu thả thì họ sẽ viết code lộn xộn, không có format. Code không format sẽ rất khó đọc và dễ dẫn đến code sai cú pháp và rất khó debug. Ví dụ như code HTML có thẻ mở mà không có thẻ đóng dẫn đến sai cấu trúc code làm hỏng cả CSS, lỗi này cũng khó debug vì dù code sai thì cũng sẽ không báo lỗi lên trình duyệt.\nĐa số các IDE hoặc code editor hiện đại đều có hỗ trợ chức năng format code theo từng ngôn ngữ, hoặc là người dùng chủ động cài thêm các plugin, extension hỗ trợ cho việc format code. Trong một project nếu các lập trình viên dùng chung một chuẩn format code cũng sẽ giúp code đồng bộ và ít bị xung đột.\n6. Hard code Hard code là nhập dữ liệu trực tiếp vào trong source code, dữ liệu này bị fix cứng và không thay đổi, cấu hình được.\nTrong một số trường hợp chúng ta vẫn dùng hard code, tuy nhiên nếu code của bạn bị hard code quá nhiều tức là đang có vấn đề. Thay vì hard code dữ liệu trong source code, hãy tách chúng ra bằng cách lấy dữ liệu qua file cấu hình, lấy từ cơ sở dữ liệu hoặc API, hay qua biến môi trường, …\nBài viết được biên dịch lại từ medium.com.😀😀\n","description":"Những lỗi cơ bản trong lập trình mà developer nên tránh.","id":23,"section":"posts","tags":null,"title":"Những lỗi cơ bản trong lập trình mà developer nên tránh","uri":"https://hungpt.info/en/posts/nhung-loi-co-ban-trong-lap-trinh-ma-developer-nen-tranh/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":24,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://hungpt.info/en/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":25,"section":"gallery","tags":null,"title":"Photo","uri":"https://hungpt.info/en/gallery/photo/"}]